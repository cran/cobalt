<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Frequently Asked Questions</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Frequently Asked Questions</h1>


<div id="TOC">
<ul>
<li><a href="#how-are-standardized-mean-differences-computed-in-cobalt" id="toc-how-are-standardized-mean-differences-computed-in-cobalt">How
are standardized mean differences computed in
<code>cobalt</code>?</a></li>
<li><a href="#why-are-mean-differences-not-standardized-for-binary-covariates" id="toc-why-are-mean-differences-not-standardized-for-binary-covariates">Why
are mean differences not standardized for binary covariates?</a></li>
<li><a href="#why-do-you-use-the-same-standardization-factor-before-and-after-adjustment" id="toc-why-do-you-use-the-same-standardization-factor-before-and-after-adjustment">Why
do you use the same standardization factor before and after
adjustment?</a></li>
<li><a href="#how-do-i-extract-the-balance-tables-from-the-bal.tab-object" id="toc-how-do-i-extract-the-balance-tables-from-the-bal.tab-object">How
do I extract the balance tables from the <code>bal.tab()</code>
object?</a></li>
<li><a href="#how-are-balance-statistics-computed-when-using-subclassification" id="toc-how-are-balance-statistics-computed-when-using-subclassification">How
are balance statistics computed when using subclassification?</a></li>
<li><a href="#why-dont-i-get-the-same-balance-statistics-when-using-cobalt-as-i-do-when-using-tableone" id="toc-why-dont-i-get-the-same-balance-statistics-when-using-cobalt-as-i-do-when-using-tableone">Why
don’t I get the same balance statistics when using <code>cobalt</code>
as I do when using <code>tableone</code>?</a></li>
<li><a href="#why-doesnt-thresholds-work-with-bal.tab-with-multiply-imputed-or-clustered-data" id="toc-why-doesnt-thresholds-work-with-bal.tab-with-multiply-imputed-or-clustered-data">Why
doesn’t <code>thresholds</code> work with <code>bal.tab()</code> with
multiply imputed or clustered data?</a></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</div>

<div id="how-are-standardized-mean-differences-computed-in-cobalt" class="section level3">
<h3>How are standardized mean differences computed in
<code>cobalt</code>?</h3>
<p>Most questions below are related to this one, so here I will try to
explain in complete detail how standardized mean differences (SMDs) are
computed.</p>
<p>First, it is important to know that by default, <strong>mean
differences for binary covariates are not standardized</strong>. That
means in the <code>Diff.Adj</code> column, etc., what you are seeing the
is <em>raw difference in proportion</em> for binary variables. (By raw,
I mean unstandardized, but weights may be applied if relevant.) To
request SMDs for binary covariates, set <code>binary = &quot;std&quot;</code> in
the call to <code>bal.tab()</code> or <code>love.plot()</code>. See also
the question below.</p>
<p>For continuous covariates, the standardized mean difference is
computed as <span class="math display">\[
\text{SMD} = \frac{\bar{x}_1 - \bar{x}_0}{s^*}
\]</span> where <span class="math inline">\(\bar{x}_1\)</span> is the
mean of the covariate in the treated group, <span class="math inline">\(\bar{x}_0\)</span> is the mean of the covariate in
the control group, and <span class="math inline">\(s^*\)</span> is a
standardization factor (not necessarily a standard deviation!). After
matching or weighting, the weighted standardized mean difference is
computed as <span class="math display">\[
\text{SMD}^w = \frac{\bar{x}_{1w} - \bar{x}_{0w}}{s^*}
\]</span> where <span class="math inline">\(\bar{x}_{1w}\)</span> is the
weighted mean of the covariate in the treated group, i.e., <span class="math inline">\(\bar{x}_{1w} = \frac{1}{\sum_{i:A_i =
1}{w_i}}\sum_{i:A_i=1}{w_ix_i}\)</span>, and similarly for the control
group. Critically, the standardization factor <span class="math inline">\(s^*\)</span> is the same before and after
weighting. I will repeat, <strong>the standardization factor</strong>
<span class="math inline">\(s^*\)</span> <strong>is the same before and
after weighting</strong>. I don’t mean it has the same formula, it mean
it is literally the same value. I explain in more detail in a question
below why this is the case.</p>
<p>How is the standardization factor computed? This depends on the
argument to <code>s.d.denom</code> supplied to <code>bal.tab()</code> or
<code>love.plot()</code>. When <code>s.d.denom</code> is not supplied,
this is determined by the argument supplied to <code>estimand</code>,
and when that is not supplied, the estimand is guessed based on the form
of the weights, if any. By default, with no weights supplied and no
argument to <code>s.d.denom</code> or <code>estimand</code>,
<code>s.d.denom</code> is set to <code>&quot;pooled&quot;</code>, and a note will
appear saying so. That note doesn’t appear if weights are supplied or
balance is assessed on the output of a another package, as the estimand,
and therefore <code>s.d.denom</code>, can be determined
automatically.</p>
<p>Below are the formulas for the standardization factor corresponding
to each value of <code>s.d.denom</code>:</p>
<ul>
<li><code>&quot;pooled&quot;</code>: <span class="math inline">\(s^* =
\sqrt{\frac{s_1^2 + s_0^2}{2}}\)</span></li>
<li><code>&quot;treated&quot;</code>: <span class="math inline">\(s^* =
s_1\)</span></li>
<li><code>&quot;control&quot;</code>: <span class="math inline">\(s^* =
s_0\)</span></li>
<li><code>&quot;all&quot;</code>: <span class="math inline">\(s^* =
s\)</span></li>
<li><code>&quot;weighted&quot;</code>: <span class="math inline">\(s^* =
s_w\)</span></li>
<li><code>&quot;hedges&quot;</code>: <span class="math inline">\(s^* = \frac{1}{1
- \frac{3}{4(n - 2) - 1}}\sqrt{\frac{(n_1 - 1)s_1^2 + (n_0 - 1)s_0^2}{n
- 2}}\)</span></li>
</ul>
<p>where <span class="math inline">\(s_1\)</span> is the standard
deviation of the treated group, <span class="math inline">\(s_0\)</span>
is the standard deviation of the control group, <span class="math inline">\(s\)</span> is the standard deviation of the whole
sample ignoring treatment group membership, <span class="math inline">\(s_w\)</span> is the weighted standard deviation of
the whole sample, <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_0\)</span> are sizes of the treated and control
groups, respectively, and <span class="math inline">\(n = n_1 +
n_0\)</span>.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> For continuous covariates, the unweighted
standard deviation is computed as usual, i.e., as <span class="math display">\[
s = \sqrt{\frac{1}{n-1}\sum_i{(x_i - \bar{x})^2}}
\]</span> and the weighted standard deviation is computed as <span class="math display">\[
s = \sqrt{\frac{\sum_{i} w_{i}}{(\sum_{i} w_{i})^2 - \sum_{i=1}^{n}
w^2_{i}}\sum_i{w_i(x_i - \bar{x}_w)^2}}
\]</span>For binary covariates, the unweighted standard deviation is
computed as <span class="math inline">\(s =
\sqrt{\bar{x}(1-\bar{x})}\)</span> and the weighted standard deviation
is computed as <span class="math inline">\(s =
\sqrt{\bar{x}_w(1-\bar{x}_w)}\)</span>.</p>
<p>When sampling weights are supplied, all standard deviations in the
standardization factor are computed incorporating the sampling weights.
When <code>s.d.denom = &quot;weighted&quot;</code>, the standardization factor is
computed using the weights used to balance the sample (i.e., the
matching or weighting weights), even for the unadjusted sample.
Remember, the standardization factor is ALWAYS the same before and after
adjustment.</p>
<p>I know some of these formulas seem overly complicated for such simple
statistics, but they are required to keep things consistent and not
dependent on the scale of the weights.</p>
</div>
<div id="why-are-mean-differences-not-standardized-for-binary-covariates" class="section level3">
<h3>Why are mean differences not standardized for binary
covariates?</h3>
<p>Ultimately, bias in the treatment effect estimate is a function of
imbalance. That bias is indifferent to whether you measure that
imbalance using a standardized or unstandardized mean difference. The
reason we use SMDs is that covariates naturally are on a variety of
different scales, and when trying to quickly assess whether a sample is
balanced, it is productive to unify the scales of the covariates. That
way, balance on a covariate measured with large numbers (e.g., days in
hospital or prior earnings in dollars) can be assessed alongside balance
on a covariate measured with small numbers (e.g., number of
comorbidities or years of education).</p>
<p>With binary covariates, though, they are already on a comprehensible
scale, so there is no need to standardize. In addition, the scale is
intuitive for people; a difference in proportion of .1 when both groups
have 100 people means that there is an imbalance of 10 people on the
covariate. Are 10 people being different enough to cause bias in the
estimate? That can be assessed substantively without needing to take the
additional step of translating the variable’s scale into something
meaningful.</p>
<p>Another important reason why mean difference are not standardized is
that it is possible for two covariates with the same imbalance to have
vastly different mean differences. For example, consider the following
dataset. <code>X1</code> and <code>X2</code> both have a mean difference
of .1; if they both affected the outcome equally, then each would
contribute to the bias in the estimate to the same extent.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>treat <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">0</span>, <span class="at">each =</span> <span class="dv">20</span>)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>X1 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>, <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">19</span>)), <span class="fu">rep</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>, <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">17</span>)))</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>X2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>, <span class="fu">c</span>(<span class="dv">9</span>, <span class="dv">11</span>)), <span class="fu">rep</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>, <span class="fu">c</span>(<span class="dv">11</span>, <span class="dv">9</span>)))</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">bal.tab</span>(treat <span class="sc">~</span> X1 <span class="sc">+</span> X2,</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>        <span class="at">binary =</span> <span class="st">&quot;raw&quot;</span>,</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>        <span class="at">disp =</span> <span class="st">&quot;means&quot;</span>,</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>        <span class="at">s.d.denom =</span> <span class="st">&quot;treated&quot;</span>)</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">#&gt; Balance Measures</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">#&gt;      Type M.0.Un M.1.Un Diff.Un</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co">#&gt; X1 Binary   0.85   0.95     0.1</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co">#&gt; X2 Binary   0.45   0.55     0.1</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">#&gt; Sample sizes</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">#&gt;     Control Treated</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="co">#&gt; All      20      20</span></span></code></pre></div>
<p>But if we standardized the mean differences, not only do we move away
from an actually interpretable statistic (i.e., what does it mean to
divide by the standard deviation of a binary variable?), we see that the
standardized mean differences vary by a huge amount, with
<code>X1</code> having twice the imbalance of <code>X2</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">bal.tab</span>(treat <span class="sc">~</span> X1 <span class="sc">+</span> X2,</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>        <span class="at">binary =</span> <span class="st">&quot;std&quot;</span>,</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>        <span class="at">s.d.denom =</span> <span class="st">&quot;treated&quot;</span>)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co">#&gt; Balance Measures</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co">#&gt;      Type Diff.Un</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co">#&gt; X1 Binary  0.4588</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co">#&gt; X2 Binary  0.2010</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co">#&gt; Sample sizes</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co">#&gt;     Control Treated</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="co">#&gt; All      20      20</span></span></code></pre></div>
<p>Why does this happen? The standard deviation of a binary variable is
a function of its mean (in particular, it is <span class="math inline">\(s = \sqrt{p(1-p)}\)</span>) where <span class="math inline">\(p\)</span> is the mean of the variable). That
means information about the mean of the variable, which is unrelated to
imbalance, contaminates the standardized mean difference, which is
supposed to measure imbalance. In this case, standardizing the mean
difference only adds confusion and reduces interpretability. That is why
mean differences for binary variables are unstandardized by default.</p>
<p>You can always change this by setting <code>binary = &quot;std&quot;</code> in
the call to <code>bal.tab()</code> or setting
<code>set.cobalt.options(binary = &quot;std&quot;)</code> to change the option for
the whole session. One advantage of using standardized mean differences
for binary variables is that they are always larger than the raw mean
difference (because the standardization factor is always less than 1),
which means if you use the standardized mean difference as your balance
criterion, you will always seek better balance than using the raw mean
differences. The balance statistics computed by
<code>bal.compute()</code> that involve the standardized mean difference
standardize all variables, including binary variables.</p>
</div>
<div id="why-do-you-use-the-same-standardization-factor-before-and-after-adjustment" class="section level3">
<h3>Why do you use the same standardization factor before and after
adjustment?</h3>
<p>It is important to remember that bias is a function of the difference
in means of a covariate, and standardization is a just tool to aid in
balance assessment. As a tool, it should reflect imbalance accurately
(i.e., without incorporating extraneous information), but there is no
statistical “truth” about the nature of the standardization factor. I
use the same standardization factor before and after adjustment as
recommended by <span class="citation">Stuart (<a href="#ref-stuartDevelopingPracticalRecommendations2008">2008</a>)</span>.
The rationale is that by isolating the SMD to reflect changes in the
difference in means, one can more accurately assess improvement in
balance rather than combining information about the difference in means
with information about the variability of the covariate, which may
change in a variety of ways after adjustment. I describe a specific
example of how allowing the standardization factor to change can cause
problems <a href="https://stats.stackexchange.com/a/565705/116195">here</a>.</p>
</div>
<div id="how-do-i-extract-the-balance-tables-from-the-bal.tab-object" class="section level3">
<h3>How do I extract the balance tables from the <code>bal.tab()</code>
object?</h3>
<p>The output of a call to <code>bal.tab()</code> is a
<code>bal.tab</code> object, which has several components depending on
the features of the dataset (e.g., whether the data are multiply imputed
or clustered or whether the treatment is binary or multi-category,
etc.). In the most basic case, a binary or continuous treatment with no
clustering, no multiple imputations, a single time point, and
subclassification is not used, the balance table is stored in the
<code>Balance</code> component of the output object. Let’s take a
look:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;lalonde&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">bal.tab</span>(treat <span class="sc">~</span> age <span class="sc">+</span> educ <span class="sc">+</span> race <span class="sc">+</span> married <span class="sc">+</span> re74,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>             <span class="at">data =</span> lalonde, <span class="at">s.d.denom =</span> <span class="st">&quot;treated&quot;</span>,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>             <span class="at">disp =</span> <span class="st">&quot;means&quot;</span>, <span class="at">stats =</span> <span class="fu">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;v&quot;</span>))</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co"># View the structure of the object</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="fu">str</span>(b, <span class="at">give.attr =</span> <span class="cn">FALSE</span>)</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">#&gt; List of 2</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co">#&gt;  $ Balance     :&#39;data.frame&#39;:    7 obs. of  9 variables:</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt;   ..$ Type       : chr [1:7] &quot;Contin.&quot; &quot;Contin.&quot; &quot;Binary&quot; &quot;Binary&quot; ...</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt;   ..$ M.0.Un     : num [1:7] 28.03 10.235 0.203 0.142 0.655 ...</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="co">#&gt;   ..$ M.1.Un     : num [1:7] 25.8162 10.3459 0.8432 0.0595 0.0973 ...</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="co">#&gt;   ..$ Diff.Un    : num [1:7] -0.3094 0.055 0.6404 -0.0827 -0.5577 ...</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a><span class="co">#&gt;   ..$ V.Ratio.Un : num [1:7] 0.44 0.496 NA NA NA ...</span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a><span class="co">#&gt;   ..$ M.0.Adj    : num [1:7] NA NA NA NA NA NA NA</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a><span class="co">#&gt;   ..$ M.1.Adj    : num [1:7] NA NA NA NA NA NA NA</span></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a><span class="co">#&gt;   ..$ Diff.Adj   : num [1:7] NA NA NA NA NA NA NA</span></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a><span class="co">#&gt;   ..$ V.Ratio.Adj: num [1:7] NA NA NA NA NA NA NA</span></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a><span class="co">#&gt;  $ Observations:&#39;data.frame&#39;:    1 obs. of  2 variables:</span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a><span class="co">#&gt;   ..$ Control: num 429</span></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a><span class="co">#&gt;   ..$ Treated: num 185</span></span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a>b<span class="sc">$</span>Balance</span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a><span class="co">#&gt;                Type       M.0.Un       M.1.Un     Diff.Un V.Ratio.Un M.0.Adj</span></span>
<span id="cb3-26"><a href="#cb3-26" tabindex="-1"></a><span class="co">#&gt; age         Contin.   28.0303030 2.581622e+01 -0.30944526  0.4399955      NA</span></span>
<span id="cb3-27"><a href="#cb3-27" tabindex="-1"></a><span class="co">#&gt; educ        Contin.   10.2354312 1.034595e+01  0.05496466  0.4958934      NA</span></span>
<span id="cb3-28"><a href="#cb3-28" tabindex="-1"></a><span class="co">#&gt; race_black   Binary    0.2027972 8.432432e-01  0.64044604         NA      NA</span></span>
<span id="cb3-29"><a href="#cb3-29" tabindex="-1"></a><span class="co">#&gt; race_hispan  Binary    0.1421911 5.945946e-02 -0.08273168         NA      NA</span></span>
<span id="cb3-30"><a href="#cb3-30" tabindex="-1"></a><span class="co">#&gt; race_white   Binary    0.6550117 9.729730e-02 -0.55771436         NA      NA</span></span>
<span id="cb3-31"><a href="#cb3-31" tabindex="-1"></a><span class="co">#&gt; married      Binary    0.5128205 1.891892e-01 -0.32363132         NA      NA</span></span>
<span id="cb3-32"><a href="#cb3-32" tabindex="-1"></a><span class="co">#&gt; re74        Contin. 5619.2365064 2.095574e+03 -0.72108381  0.5181285      NA</span></span>
<span id="cb3-33"><a href="#cb3-33" tabindex="-1"></a><span class="co">#&gt;             M.1.Adj Diff.Adj V.Ratio.Adj</span></span>
<span id="cb3-34"><a href="#cb3-34" tabindex="-1"></a><span class="co">#&gt; age              NA       NA          NA</span></span>
<span id="cb3-35"><a href="#cb3-35" tabindex="-1"></a><span class="co">#&gt; educ             NA       NA          NA</span></span>
<span id="cb3-36"><a href="#cb3-36" tabindex="-1"></a><span class="co">#&gt; race_black       NA       NA          NA</span></span>
<span id="cb3-37"><a href="#cb3-37" tabindex="-1"></a><span class="co">#&gt; race_hispan      NA       NA          NA</span></span>
<span id="cb3-38"><a href="#cb3-38" tabindex="-1"></a><span class="co">#&gt; race_white       NA       NA          NA</span></span>
<span id="cb3-39"><a href="#cb3-39" tabindex="-1"></a><span class="co">#&gt; married          NA       NA          NA</span></span>
<span id="cb3-40"><a href="#cb3-40" tabindex="-1"></a><span class="co">#&gt; re74             NA       NA          NA</span></span></code></pre></div>
<p>It’s not a very pretty object, which is why the <code>print()</code>
method makes it look nicer. If you are willing to process this table
yourself, you can easily extract it from the <code>bal.tab()</code>
output and do what you want with it, e.g., saving it to a CSV file or
making a pretty table using another package. Although I have been
working on a way to do this more easily (i.e., to create a
publication-ready table from a <code>bal.tab</code> object), it might be
a while because the main purpose of this package is balance assessment,
not formatting for publication (although I did put a lot of work into
<code>love.plot()</code> to make it customizable for publication).</p>
</div>
<div id="how-are-balance-statistics-computed-when-using-subclassification" class="section level3">
<h3>How are balance statistics computed when using
subclassification?</h3>
<p>Subclassification involves creating strata (usually based on the
propensity score), within which covariates are ideally balanced.
<code>bal.tab()</code> lets you assess balance both within and across
subclasses.</p>
<p>One must always remember that the standardized mean difference uses
the standardization factor computed in the original sample, i.e., prior
to subclassification. Let’s take a look below using
<code>MatchIt</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># PS Subclassification</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>msub <span class="ot">&lt;-</span> MatchIt<span class="sc">::</span><span class="fu">matchit</span>(treat <span class="sc">~</span> age <span class="sc">+</span> educ <span class="sc">+</span> race <span class="sc">+</span> married <span class="sc">+</span> re74,</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>                         <span class="at">data =</span> lalonde, <span class="at">method =</span> <span class="st">&quot;subclass&quot;</span>,</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>                         <span class="at">estimand =</span> <span class="st">&quot;ATE&quot;</span>, <span class="at">min.n =</span> <span class="dv">4</span>)</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co"># Balance in the first subclass</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="fu">bal.tab</span>(msub, <span class="at">which.sub =</span> <span class="dv">1</span>, <span class="at">binary =</span> <span class="st">&quot;std&quot;</span>)</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt; Balance by subclass</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt;  - - - Subclass 1 - - - </span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt;                 Type Diff.Adj</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; distance    Distance   0.1574</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt; age          Contin.  -1.0433</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt; educ         Contin.  -0.2759</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="co">#&gt; race_black    Binary   0.0000</span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="co">#&gt; race_hispan   Binary   0.0000</span></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="co">#&gt; race_white    Binary   0.0000</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a><span class="co">#&gt; married       Binary  -1.1135</span></span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a><span class="co">#&gt; re74         Contin.  -1.8353</span></span></code></pre></div>
<p>Let’s see where the number <code>-1.0433</code> came from (the
standardized mean difference for <code>age</code>). We compute the mean
of <code>age</code> in each treatment group in subclass 1, and then
divide it by the pooled standard deviation of age (because we requested
the ATE) in <em>the original sample</em>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>m0 <span class="ot">&lt;-</span> <span class="fu">mean</span>(lalonde<span class="sc">$</span>age[lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">0</span> <span class="sc">&amp;</span> msub<span class="sc">$</span>subclass <span class="sc">==</span> <span class="dv">1</span>])</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>m1 <span class="ot">&lt;-</span> <span class="fu">mean</span>(lalonde<span class="sc">$</span>age[lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span> <span class="sc">&amp;</span> msub<span class="sc">$</span>subclass <span class="sc">==</span> <span class="dv">1</span>])</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>s0 <span class="ot">&lt;-</span> <span class="fu">sd</span>(lalonde<span class="sc">$</span>age[lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">0</span>])</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>s1 <span class="ot">&lt;-</span> <span class="fu">sd</span>(lalonde<span class="sc">$</span>age[lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span>])</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>(m1 <span class="sc">-</span> m0) <span class="sc">/</span> <span class="fu">sqrt</span>((s1<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> s0<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> <span class="dv">2</span>)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; [1] -1.043294</span></span></code></pre></div>
<p>A common mistake is to compute the standard deviation within each
subclass. There are a few reasons why this is bad: 1) it suffers from
the same problem that changing the standardization factor does with
matching or weighting, i.e., that balance can appear to be worse because
the standardization factor shrank even as the means got closer together;
2) when there is no or little variation of a covariate within a
subclass, which is desirable, the standardization factor will be tiny,
making the SMD potentially appear huge; and 3) the same variable will
use different standardization factors across subclasses, which means the
same difference in means, which contribute to bias equally, will have
different balance statistics.</p>
<p>A related question is how the balance statistics are computed across
subclasses to compute an overall balance statistic for the sample. For
(standardized) mean differences, it is as easy as computing the average
of the statistic across subclasses, where the statistics are weighted
corresponding to the number of units in the subclass in the target group
(e.g., the treated units for the ATT, all units for the ATE, etc.).
Below I’ll demonstrate how to do that manually for the <code>age</code>
covariate:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># SMDs across subclasses for age</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>smds <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="cf">function</span>(s) {</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>    m0 <span class="ot">&lt;-</span> <span class="fu">mean</span>(lalonde<span class="sc">$</span>age[lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">0</span> <span class="sc">&amp;</span> msub<span class="sc">$</span>subclass <span class="sc">==</span> s])</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>    m1 <span class="ot">&lt;-</span> <span class="fu">mean</span>(lalonde<span class="sc">$</span>age[lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span> <span class="sc">&amp;</span> msub<span class="sc">$</span>subclass <span class="sc">==</span> s])</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>    </span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>    s0 <span class="ot">&lt;-</span> <span class="fu">sd</span>(lalonde<span class="sc">$</span>age[lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">0</span>])</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    s1 <span class="ot">&lt;-</span> <span class="fu">sd</span>(lalonde<span class="sc">$</span>age[lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span>])</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>    </span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    (m1 <span class="sc">-</span> m0) <span class="sc">/</span> <span class="fu">sqrt</span>((s1<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> s0<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> <span class="dv">2</span>)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>})</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co"># Sample size in each subclass</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>ns <span class="ot">&lt;-</span> <span class="fu">table</span>(msub<span class="sc">$</span>subclass)</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a><span class="co"># Summary SMD for age</span></span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a><span class="fu">weighted.mean</span>(smds, ns)</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a><span class="co">#&gt; [1] -0.2354095</span></span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a><span class="fu">bal.tab</span>(msub)</span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a><span class="co">#&gt; Balance measures across subclasses</span></span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a><span class="co">#&gt;                 Type Diff.Adj</span></span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a><span class="co">#&gt; distance    Distance   0.1081</span></span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a><span class="co">#&gt; age          Contin.  -0.2354</span></span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a><span class="co">#&gt; educ         Contin.   0.0075</span></span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a><span class="co">#&gt; race_black    Binary   0.0535</span></span>
<span id="cb6-26"><a href="#cb6-26" tabindex="-1"></a><span class="co">#&gt; race_hispan   Binary  -0.0420</span></span>
<span id="cb6-27"><a href="#cb6-27" tabindex="-1"></a><span class="co">#&gt; race_white    Binary  -0.0115</span></span>
<span id="cb6-28"><a href="#cb6-28" tabindex="-1"></a><span class="co">#&gt; married       Binary  -0.1160</span></span>
<span id="cb6-29"><a href="#cb6-29" tabindex="-1"></a><span class="co">#&gt; re74         Contin.  -0.3200</span></span>
<span id="cb6-30"><a href="#cb6-30" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-31"><a href="#cb6-31" tabindex="-1"></a><span class="co">#&gt; Sample sizes by subclass</span></span>
<span id="cb6-32"><a href="#cb6-32" tabindex="-1"></a><span class="co">#&gt;           1   2  3   4   5   6 All</span></span>
<span id="cb6-33"><a href="#cb6-33" tabindex="-1"></a><span class="co">#&gt; Control 102 100 88  72  39  28 429</span></span>
<span id="cb6-34"><a href="#cb6-34" tabindex="-1"></a><span class="co">#&gt; Treated   4   4  9  30  62  76 185</span></span>
<span id="cb6-35"><a href="#cb6-35" tabindex="-1"></a><span class="co">#&gt; Total   106 104 97 102 101 104 614</span></span></code></pre></div>
<p>This works for mean differences but not other statistics. So the way
<code>cobalt</code> actually does this is compute stratification
weights, and then compute the balance statistics using the
stratification weights in the full sample. Stratification weights are
first computed by computing the proportion of treated units in each
sample, and then using the formulas to compute propensity score weights
from propensity scores. Here’s how I do that manually for
<code>age</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># Compute proportion of treated units in each subclass</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>prop1 <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="cf">function</span>(s) <span class="fu">mean</span>(lalonde<span class="sc">$</span>treat[msub<span class="sc">$</span>subclass <span class="sc">==</span> s]))</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co"># Assign to each unit</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>ps <span class="ot">&lt;-</span> prop1[msub<span class="sc">$</span>subclass]</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co"># Compute ATE weights</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>w <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(lalonde<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span>, <span class="dv">1</span> <span class="sc">/</span> ps, <span class="dv">1</span> <span class="sc">/</span> (<span class="dv">1</span> <span class="sc">-</span> ps))</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co"># Compute weighted KS statistic</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="fu">col_w_ks</span>(lalonde<span class="sc">$</span>age, <span class="at">treat =</span> lalonde<span class="sc">$</span>treat,</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>         <span class="at">weights =</span> w)</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co">#&gt; [1] 0.1658923</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="fu">bal.tab</span>(msub, <span class="at">stats =</span> <span class="st">&quot;ks&quot;</span>)</span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a><span class="co">#&gt; Balance measures across subclasses</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a><span class="co">#&gt;                 Type KS.Adj</span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a><span class="co">#&gt; distance    Distance 0.2187</span></span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a><span class="co">#&gt; age          Contin. 0.1659</span></span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a><span class="co">#&gt; educ         Contin. 0.0627</span></span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a><span class="co">#&gt; race_black    Binary 0.0535</span></span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a><span class="co">#&gt; race_hispan   Binary 0.0420</span></span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a><span class="co">#&gt; race_white    Binary 0.0115</span></span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a><span class="co">#&gt; married       Binary 0.1160</span></span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a><span class="co">#&gt; re74         Contin. 0.3038</span></span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a><span class="co">#&gt; Sample sizes by subclass</span></span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a><span class="co">#&gt;           1   2  3   4   5   6 All</span></span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a><span class="co">#&gt; Control 102 100 88  72  39  28 429</span></span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a><span class="co">#&gt; Treated   4   4  9  30  62  76 185</span></span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a><span class="co">#&gt; Total   106 104 97 102 101 104 614</span></span></code></pre></div>
</div>
<div id="why-dont-i-get-the-same-balance-statistics-when-using-cobalt-as-i-do-when-using-tableone" class="section level3">
<h3>Why don’t I get the same balance statistics when using
<code>cobalt</code> as I do when using <code>tableone</code>?</h3>
<p><code>tableone</code> is another package that provides tools for
balance assessment. One strength that the package has is its beautiful,
publication-ready tables that include summary statistics for the
covariates, clean variable names, and clean headings. But it does not
incorporate best practices in balance assessment in favor of
transparency. This differs from the ethos of <code>cobalt</code>, which
is to provide highly customizable balance statistics that reflect best
practices and use well-reasoned decisions. This is not an insult to
<code>tableone</code> but is meant to reflect the different purposes
<code>cobalt</code> and <code>tableone</code> have. They should not be
used interchangeably or expect to yield identical results because they
use different formulas for computing certain statistics, most notably
the SMD.</p>
<p>Below are some of the reasons why SMDs might differ between
<code>tableone</code> and <code>cobalt</code>:</p>
<ul>
<li><code>tableone</code> always uses the pooled standard deviation
(i.e., the standardizaton factor setting
<code>s.d.denom = &quot;pooled&quot;</code>) as the standardization factor, while
<code>cobalt</code> determines the standardization factor based on the
estimand (though by default or when the ATE is the estimand, the two
should be aligned).</li>
<li><code>tableone</code> uses the weighted standardization factor in
the SMD, whereas <code>cobalt</code> always uses the standardization
factor computed in the unadjusted sample. For matching, this means
<code>tableone</code> computes the standardization factor in the matched
sample, while <code>cobalt</code> uses the original sample.</li>
<li><code>tableone</code> uses <code>survey::svyvar()</code> to compute
weighted variances, whereas <code>cobalt</code> uses the formula
described previously (and implemented in <code>col_w_sd()</code>). These
values will differ by small amounts when the weights are not
constant.</li>
<li>For multi-category covariates, <code>tableone</code> uses a single
statistic described by <span class="citation">Yang and Dalton (<a href="#ref-yangUnifiedApproachMeasuring2012">2012</a>)</span> to
summarize balance, whereas <code>cobalt</code> provides a balance
statistic for each level of the covariate. There is no reason to prefer
the statistic used by <code>tableone</code>; it does not have any
relationship to the bias of the estimate and can mask large differences
in some categories when there are many categories. See <a href="https://stats.stackexchange.com/a/496608/116195">here</a> for a
more detailed answer.</li>
</ul>
<p>In practice, these differences will be small. Obviously, I recommend
using <code>cobalt</code> instead for balance assessment, and I
recommend reporting the balance statistics <code>cobalt</code> produces.
That said, if you understand what <code>tableone</code> is doing and are
okay with the choices it makes, there is no denying that it can produce
beautiful tables.</p>
</div>
<div id="why-doesnt-thresholds-work-with-bal.tab-with-multiply-imputed-or-clustered-data" class="section level3">
<h3>Why doesn’t <code>thresholds</code> work with <code>bal.tab()</code>
with multiply imputed or clustered data?</h3>
<p>This question was asked <a href="https://github.com/ngreifer/cobalt/issues/90">here</a> and <a href="https://stackoverflow.com/q/79562364/6348551">here</a>. With
multiply imputed data, the default output of <code>bal.tab()</code> is
the balance summary across imputations, which contains, for each balance
statistic and for each covariate, the minimum, mean, and maximum value
of that balance statistic for that covariate across imputations. When
you request a balance threshold using <code>thresholds</code>, it isn’t
clear to <code>bal.tab()</code> which of those summaries the threshold
is to be applied to. To get thresholds to appear, supply an argument to
<code>imp.fun</code> to request just one summary, e.g.,
<code>imp.fun = &quot;mean&quot;</code>, and the thresholds will be applied to
that summary.</p>
<p>For clustered data, the same is true, but the across-cluster balance
summary is not displayed by default. To request a single summary, use
<code>cluster.fun</code>.</p>
<p>Note this does not apply to <code>love.plot()</code>, which will
produce thresholds even when the default <code>agg.fun</code>
(<code>&quot;range&quot;</code> for multiply imputed data) is requested.</p>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-stuartDevelopingPracticalRecommendations2008" class="csl-entry">
Stuart, Elizabeth A. 2008. <span>“Developing Practical Recommendations
for the Use of Propensity Scores: Discussion of <span>‘<span>A</span>
Critical Appraisal of Propensity Score Matching in the Medical
Literature Between 1996 and 2003’</span> by <span>Peter Austin</span>,
<span>Statistics</span> in <span>Medicine</span>.”</span> <em>Statistics
in Medicine</em> 27 (12): 2062–65. <a href="https://doi.org/10.1002/sim.3207">https://doi.org/10.1002/sim.3207</a>.
</div>
<div id="ref-yangUnifiedApproachMeasuring2012" class="csl-entry">
Yang, Dongsheng, and Jarrod E Dalton. 2012. <span>“A Unified Approach to
Measuring the Effect Size Between Two Groups Using SAS®,”</span> 6.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>For multi-category treatments, all standardization
factors are computed using the full data, not just the groups being
compared. For example, the pooled standard deviation involves computing
the mean of all the group-specific variances, not just the two being
compared. Similarly, in the <code>&quot;hedges&quot;</code> formula, <span class="math inline">\(n-2\)</span> is replaced with <span class="math inline">\(n-k\)</span>, where <span class="math inline">\(k\)</span> is the number of treatment groups.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
